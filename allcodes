BPSK 
clc; clear all; close all; 
data_bits = 10000; 
b = (randn(1, data_bits) > 0.5); 
s = 2*b - 1;  % BPSK symbols 
SNRd_B = 0:9; 
for k = 1:length(SNRd_B) 
y = s + awgn(s, SNRd_B(k)); 
error = 0; 
for c = 1:data_bits 
if (y(c)>0 && s(c)==-1) || (y(c)<0 && s(c)==1) 
error = error + 1; 
end 
end 
BER(k) = error / data_bits; % now BER is defined 
end 
% Replace zeros to avoid log(0) 
BER(BER==0) = 1e-6; 
figure; 
semilogy(SNRd_B, BER, 'r', 'LineWidth', 2); 
hold on; 
SNR = 10.^(SNRd_B/10); 
BER_thBPSK = (1/2)*erfc(sqrt(SNR)); 
BER_thBPSK(BER_thBPSK==0) = 1e-6; % Avoid log(0) 
semilogy(SNRd_B, BER_thBPSK, 'k', 'LineWidth', 2); 
BER_thQPSK = erfc(sqrt(SNR)); 
BER_thQPSK(BER_thQPSK==0) = 1e-6; % Avoid log(0) 
semilogy(SNRd_B, BER_thQPSK, 'b', 'LineWidth', 2); 
grid on; 
xlabel('SNR (dB)'); 
ylabel('Bit Error Rate'); 
legend('Simulated BER', 'BPSK Theory', 'QPSK Theory'); 
Cyclic 
clc; clear all; close all; 
%%% --- Input code parameters --- 
n = input('Enter codeword length n: '); 
k = input('Enter number of data bits k: '); 
m = input('Enter number of data bits m: '); % Note: This should likely be m = n-k 
m = n - k; % number of parity bits 
%%% --- Generator polynomial --- 
G = cyclpoly(n, k, 'max'); 
disp('Generator polynomial:'); disp(G) 
gx=poly2sym(G) 
%%% --- Generate all possible data messages --- 
data = de2bi(0:2^k-1, k, 'left-msb'); % All messages 
disp('Data messages:'); disp(data) 
%%% --- Encode messages using cyclic code --- 
codewords = zeros(size(data,1), n); 
for i = 1:size(data,1) 
cw_poly = mod(conv(data(i,:), G), 2); 
codewords(i,:) = cw_poly(end-n+1:end); 
end 
disp('Encoded codewords:'); disp(codewords) 
%%% --- Hamming code parity-check matrix --- 
H = hammgen(m); 
syndrome_table = syndtable(H); 
%%% --- Input a received codeword manually --- 
fprintf('\nEnter received codeword (length %d) as a row vector, e.g., [1 0 1 ...]:\n', n); 
recd = input('Received codeword: '); 
%%% --- Compute syndrome --- 
syndrome = mod(recd * H', 2); 
syndrome_dec = bi2de(syndrome,'left-msb'); 
%%% --- Find and correct error --- 
error_pattern = syndrome_table(1 + syndrome_dec, :); 
corrected = mod(recd + error_pattern, 2); 
%%% --- Display results --- 
fprintf('\nReceived codeword:  '); disp(recd); 
fprintf('Syndrome:           
'); disp(syndrome); 
fprintf('Error pattern:     
 '); disp(error_pattern); 
fprintf('Corrected codeword: '); disp(corrected); 

Huffman 
clc; 
clear all; 
close all; 
code_length=0; 
x=input('Enter number of symbols: '); 
symbols = 1:x; 
p = zeros(1,x); 
for i=1:x 
p(i) = input(['Enter probability of symbol ',num2str(i),': ']); 
end 
p= sort(p,'descend') 
Hx = 0; 
Total_code_len = 0;     % initialize accumulator 
for m = 1:x 
dict = huffmandict(symbols, p); 
hcode = huffmanenco(symbols(m), dict);   % encode actual symbol 
dsig = huffmandeco(hcode, dict); 
Hx = Hx + p(m) * (-log2(p(m)));          
code_length = length(hcode);             
% entropy 
% length of codeword 
Total_code_len = Total_code_len + p(m)*code_length;  % accumulate 
end 
avglen = Total_code_len;   % final average length 
fprintf('Entropy H(X) = %.4f bits\n', Hx); 
fprintf('Average Code Length = %.4f bits\n', avglen); 
fprintf('Efficiency = %.2f %%\n', (Hx/avglen)*100); 


LBC 
clc; 
clear all; 
%input generated matrix 
g=input('enter the generator matrix:') 
%disp('g=') 
disp(g) 
disp('the order of the linear block code for given generator matrix is:') 
[n,k]=size(transpose(g)) 
for i=1:2^k 
    for j=k:-1:1 
        if rem(i-1,2^(-j+k+1))>=2^(-j+k) 
            u(i,j)=1; 
        else 
            u(i,j)=0; 
        end 
    end 
end 
u; 
disp('the possible codewords are:') 
c=rem(u*g,2) 
disp('the minimum hamming distance dmin for given block code=') 
d_min=min(sum((c(2:2^k,:))')) 
%codeword 
r=input('enter the received code word:') 
p=[g(:,n-k+2:n)]; 
h=[transpose(p),eye(n-k)]; 
%disp('hamming code') 
ht=transpose(h) 
%disp('syndrome of a given codeword is:') 
s=rem(r*ht,2) 
for i=1:1:size(ht) 
    if (ht(1,1:3)==s) 
        r(i)=1-r(i); 
        break; 
    end 
end 
disp('the error is in bit:') 
i 
disp('the corrected codeword is:') 
r 
 
 
 
 
 
 
 
 
MSK QAM 
clc; 
clear all; 
close all; 
N=input('Enter number of bits to be grouped: '); 
M=2^N; 
x=[0:M-1]; 
k=1; 
OFF=0; 
z=pskmod(x,M); 
scatterplot(z,k,OFF,'r+'); 
title('M-ary PSK') 
y=qammod(x,M); 
scatterplot(y,k,OFF,'b*'); 
title('M-QAM') 


Random 
clc; 
clear all; 
close all; 
x = -6:0.1:6; 
% ---------------- CASE 1 ------------------- 
m = -1; sd = 1; 
y1 = normpdf(x, m, sd); 
% ---------------- CASE 2 ------------------- 
m = 0; sd = 1; 
y2 = normpdf(x, m, sd); 
% ---------------- CASE 3 ------------------- 
m = 1; sd = 1; 
y3 = normpdf(x, m, sd); 
% ------ Single Figure with 3 Subplots ------ 
figure; 
% Left Plot 
subplot(1,3,1); 
plot(x, y1, 'b', 'LineWidth', 2); 
title('CASE-1: mean = -1, std dev = 1'); 
xlabel('x values ->'); ylabel('PDF ->'); 
grid on; 
% Middle Plot 
subplot(1,3,2); 
plot(x, y2, 'r', 'LineWidth', 2); 
title('CASE-2: mean = 0, std dev = 1'); 
xlabel('x values ->'); %ylabel('PDF ->'); 
grid on; 
% Right Plot 
subplot(1,3,3); 
plot(x, y3, 'g', 'LineWidth', 2); 
title('CASE-3: mean = 1, std dev = 1'); 
xlabel('x values ->'); %ylabel('PDF ->'); 
grid on;
